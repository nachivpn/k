{-# OPTIONS --allow-unsolved-metas #-}
module IS4.Reduction where

open import IS4.Term
open import IS4.HellOfSyntacticLemmas

open import Relation.Nullary
  using (Â¬_)

open import Relation.Binary
  using (Preorder)

open import Relation.Binary.Construct.Closure.ReflexiveTransitive
  as ReflexiveTransitive
  using (Star)
open import Relation.Binary.Construct.Closure.ReflexiveTransitive.Properties
  using (preorder)
open import Relation.Binary.PropositionalEquality as PE
  using (_â‰¡_ ; refl ; sym ; trans ; cong ; congâ‚‚)

open ReflexiveTransitive public
  using (Îµ ; _â—…_)

-------------------
-- Reduction rules
-------------------

data _âŸ¶_ : Tm Î“ a â†’ Tm Î“ a â†’ Set where

  red-fun : (t : Tm (Î“ `, a) b) (u : Tm Î“ a)
    â†’ app (lam t) u âŸ¶ substTm (idâ‚› `, u) t

  exp-fun : (t : Tm Î“ (a â‡’ b))
    â†’ t âŸ¶ lam (app (wkTm fresh t) (var ze))

  red-box : (t : Tm (Î“L ðŸ”’) a) (e : CExt Î“ Î“L Î“R)
    â†’ unbox (box t) e âŸ¶ substTm (lock idâ‚› e) t

  exp-box : (t : Tm Î“ (â—» a))
    â†’ t âŸ¶ box (unbox t new)

  cong-lam : {t t' : Tm (Î“ `, a) b}
    â†’ t âŸ¶ t'
    â†’ lam t âŸ¶ lam t'

  cong-app1 : {t t' : Tm Î“ (a â‡’ b)} {u : Tm Î“ a}
    â†’ t âŸ¶ t'
    â†’ app t u âŸ¶ app t' u

  cong-app2 : {t : Tm Î“ (a â‡’ b)} {u u' : Tm Î“ a}
    â†’ u âŸ¶ u'
    â†’ app t u âŸ¶ app t u'

  cong-box : {t t' : Tm (Î“ ðŸ”’) a}
    â†’ t âŸ¶ t'
    â†’ box t âŸ¶ box t'

  cong-unbox : {t t' : Tm Î“L (â—» a)} {e : CExt Î“ Î“L Î“R}
    â†’ t âŸ¶ t'
    â†’ unbox t e âŸ¶ unbox t' e

  fact-unbox : {t : Tm Î“L (â—» a)} {e : CExt Î“ Î“L Î“R}
    â†’ unbox t e âŸ¶ unbox (substTm (factorSubâ‚› e idâ‚›) t) (factorExtâ‚› e idâ‚›)


-- zero or more steps of reduction
Tm-preorder : (Î“ : Ctx) â†’ (a : Ty) â†’ Preorder _ _ _
Tm-preorder Î“ a = preorder (_âŸ¶_ {Î“} {a})

module _ {Î“ : Ctx} {a : Ty} where
  open Preorder (Tm-preorder Î“ a) public
    using    ()
    renaming (_âˆ¼_ to _âŸ¶*_ ; refl to âŸ¶-refl ; reflexive to zero ; trans to multi)

one : {t t' : Tm Î“ a} â†’ t âŸ¶ t' â†’ t âŸ¶* t'
one t = t â—… Îµ

module _ {t : Tm Î“ a â†’ Tm Î” b} (cong-t : âˆ€ {u u' : Tm Î“ a} â†’ (uâŸ¶u' : u âŸ¶ u') â†’ t u âŸ¶* t u') where
  cong-âŸ¶*-to-cong-âŸ¶* : âˆ€ (uâŸ¶*u' : u âŸ¶* u') â†’ t u âŸ¶* t u'
  cong-âŸ¶*-to-cong-âŸ¶* Îµ                 = Îµ
  cong-âŸ¶*-to-cong-âŸ¶* (uâŸ¶u'' â—… u''âŸ¶*u') = multi (cong-t uâŸ¶u'') (cong-âŸ¶*-to-cong-âŸ¶* u''âŸ¶*u')

cong-âŸ¶-to-cong-âŸ¶* : {t : Tm Î“ a â†’ Tm Î” b} (cong-t : âˆ€ {u u' : Tm Î“ a} â†’ (uâŸ¶u' : u âŸ¶ u') â†’ t u âŸ¶ t u') (uâŸ¶*u' : u âŸ¶* u') â†’ t u âŸ¶* t u'
cong-âŸ¶-to-cong-âŸ¶* cong-t = cong-âŸ¶*-to-cong-âŸ¶* (Î» uâŸ¶u' â†’ one (cong-t uâŸ¶u'))

cong-app : {t t' : Tm Î“ (a â‡’ b)} {u u' : Tm Î“  a}
  â†’ t âŸ¶ t' â†’ u âŸ¶ u'
  â†’ app t u âŸ¶* app t' u'
cong-app tâŸ¶t' uâŸ¶u' = cong-app1 tâŸ¶t' â—… cong-app2 uâŸ¶u' â—… Îµ

cong-box* : {t t' : Tm (Î“ ðŸ”’) a}
  â†’ t âŸ¶* t'
  â†’ box t âŸ¶* box t'
cong-box* = cong-âŸ¶-to-cong-âŸ¶* cong-box

cong-unbox* : {t t' : Tm Î“L (â—» a)} {e : CExt Î“ Î“L Î“R}
  â†’ t âŸ¶* t'
  â†’ unbox t e âŸ¶* unbox t' e
cong-unbox* = cong-âŸ¶-to-cong-âŸ¶* cong-unbox

cong-lam* : {t t' : Tm (Î“ `, a) b}
  â†’ t âŸ¶* t'
  â†’ lam t âŸ¶* lam t'
cong-lam* = cong-âŸ¶-to-cong-âŸ¶* cong-lam

cong-app1* : {t t' : Tm Î“ (a â‡’ b)} {u : Tm Î“  a}
  â†’ t âŸ¶* t'
  â†’ app t u âŸ¶* app t' u
cong-app1* = cong-âŸ¶-to-cong-âŸ¶* cong-app1

cong-app2* : {t : Tm Î“ (a â‡’ b)} {u u' : Tm Î“  a}
  â†’ u âŸ¶* u'
  â†’ app t u âŸ¶* app t u'
cong-app2* = cong-âŸ¶-to-cong-âŸ¶* cong-app2

cong-app*  : {t t' : Tm Î“ (a â‡’ b)} {u u' : Tm Î“  a}
  â†’ t âŸ¶* t' â†’ u âŸ¶* u'
  â†’ app t u âŸ¶* app t' u'
cong-app* tâŸ¶*t' uâŸ¶*u' = multi (cong-app1* tâŸ¶*t') (cong-app2* uâŸ¶*u')

data _âŸ¶â‚›*_ : Sub Î” Î“ â†’ Sub Î” Î“ â†’ Set where
  Îµ          : {s : Sub Î” Î“}
    â†’ s âŸ¶â‚›* s
  multiâ‚›      : {s s' s'' : Sub Î” Î“}
    â†’ s âŸ¶â‚›* s' â†’ s' âŸ¶â‚›* s'' â†’ s âŸ¶â‚›* s''
  cong-`,*   : {s s' : Sub Î” Î“} {t t' : Tm Î” a}
    â†’ s âŸ¶â‚›* s' â†’ t âŸ¶* t' â†’ (s `, t) âŸ¶â‚›* (s' `, t')
  cong-lock*  : {s s' : Sub Î”L Î“L} {e : CExt Î” Î”L Î”R}
    â†’ s âŸ¶â‚›* s' â†’ lock s e âŸ¶â‚›* lock s' e
  fact-lock* : {s : Sub Î”L Î“L} {e : CExt Î” Î”L Î”R}
    â†’ lock s e âŸ¶â‚›* lock (s âˆ™â‚› factorSubâ‚› e idâ‚›) (factorExtâ‚› e idâ‚›)

zeroâ‚› : {s s' : Sub Î” Î“} â†’ s â‰¡ s' â†’ s âŸ¶â‚›* s'
zeroâ‚› refl = Îµ

substTmPresId : (t : Tm Î“ a) â†’ t âŸ¶* substTm idâ‚› t
substTmPresId (var x)     = zero (sym (substVarPresId x))
substTmPresId (lam t)     = cong-lam* (substTmPresId t)
substTmPresId (app t u)   = cong-app* (substTmPresId t) (substTmPresId u)
substTmPresId (box t)     = cong-box* (substTmPresId t)
substTmPresId (unbox t e) = one fact-unbox

rightIdSub : (s : Sub Î“ Î“') â†’ s âŸ¶â‚›* (s âˆ™â‚› idâ‚›)
rightIdSub []         = Îµ
rightIdSub (s `, t)   = cong-`,* (rightIdSub s) (substTmPresId t)
rightIdSub (lock s e) = fact-lock*

invRed :  {t t' : Tm Î“ a}
  â†’ (w : Î“ âŠ† Î“')
  â†’ t âŸ¶ t'
  â†’ wkTm w t âŸ¶* wkTm w t'
invRed w (red-fun t u)
  = multi (one (red-fun _ _)) (zero (beta-wk-lemma w u t))
invRed w (exp-fun _)
  = multi (one (exp-fun _)) (zero (cong lam (congâ‚‚ app keepFreshLemma refl)))
invRed w (red-box t e)
  = multi (one (red-box _ _)) (zero (trans (trans (sym (coh-trimSub-wkTm t _ _)) {!!}) (nat-substTm t _ w)))
  -- use `coh-trimSub-wkSub idâ‚› idâ‚› (factorWk e w)` and substitution identities
invRed w (exp-box _)
  = one (exp-box _)
invRed w (cong-lam r)
  = cong-lam* (invRed (keep w) r)
invRed w (cong-box r)
  = cong-box* (invRed (keepðŸ”’ w) r)
invRed w (cong-unbox {e = e} r)
  = cong-unbox* (invRed (factorWk e w ) r)
invRed w (cong-app1 r)
  = cong-app* (invRed w r) Îµ
invRed w (cong-app2 r)
  = cong-app* Îµ (invRed w r)
invRed w fact-unbox = {!!}

wkTmPresâŸ¶* :  {t t' : Tm Î“ a}
  â†’ (w : Î“ âŠ† Î“')
  â†’ t âŸ¶* t'
  â†’ wkTm w t âŸ¶* wkTm w t'
wkTmPresâŸ¶* w = cong-âŸ¶*-to-cong-âŸ¶* (invRed w)
